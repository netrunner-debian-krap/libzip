--- a/lib/zip_close.c
+++ b/lib/zip_close.c
@@ -191,7 +191,8 @@ zip_close(struct zip *za)
 		error = 1;
 		break;
 	    }
-	    if (_zip_dirent_read(&de, za->zp, NULL, 0, 1, &za->error) != 0) {
+	    if (_zip_dirent_read(&de, za->zp, NULL, NULL, 1,
+				 &za->error) != 0) {
 		error = 1;
 		break;
 	    }
--- a/lib/zip_dirent.c
+++ b/lib/zip_dirent.c
@@ -68,6 +68,30 @@ _zip_cdir_free(struct zip_cdir *cd)
 
 
 
+int
+_zip_cdir_grow(struct zip_cdir *cd, int nentry, struct zip_error *error)
+{
+    struct zip_dirent *entry;
+
+    if (nentry < cd->nentry) {
+	_zip_error_set(error, ZIP_ER_INTERNAL, 0);
+	return -1;
+    }
+
+    if ((entry=((struct zip_dirent *)
+		realloc(cd->entry, sizeof(*(cd->entry))*nentry))) == NULL) {
+	_zip_error_set(error, ZIP_ER_MEMORY, 0);
+	return -1;
+    }
+
+    cd->nentry = nentry;
+    cd->entry = entry;
+
+    return 0;
+}
+
+
+
 struct zip_cdir *
 _zip_cdir_new(int nentry, struct zip_error *error)
 {
@@ -173,19 +197,23 @@ _zip_dirent_init(struct zip_dirent *de)
    Fills the zip directory entry zde.
 
    If bufp is non-NULL, data is taken from there and bufp is advanced
-   by the amount of data used; no more than left bytes are used.
-   Otherwise data is read from fp as needed.
+   by the amount of data used; otherwise data is read from fp as needed.
+   
+   if leftp is non-NULL, no more bytes than specified by it are used,
+   and *leftp is reduced by the number of bytes used.
 
-   If localp != 0, it reads a local header instead of a central
+   If local != 0, it reads a local header instead of a central
    directory entry.
 
    Returns 0 if successful. On error, error is filled in and -1 is
    returned.
+
+   XXX: leftp and file position undefined on error.
 */
 
 int
 _zip_dirent_read(struct zip_dirent *zde, FILE *fp,
-		 unsigned char **bufp, unsigned int left, int localp,
+		 unsigned char **bufp, unsigned int *leftp, int local,
 		 struct zip_error *error)
 {
     unsigned char buf[CDENTRYSIZE];
@@ -193,18 +221,19 @@ _zip_dirent_read(struct zip_dirent *zde,
     unsigned short dostime, dosdate;
     unsigned int size;
 
-    if (localp)
+    if (local)
 	size = LENTRYSIZE;
     else
 	size = CDENTRYSIZE;
-    
+
+    if (leftp && (*leftp < size)) {
+	_zip_error_set(error, ZIP_ER_NOZIP, 0);
+	return -1;
+    }
+
     if (bufp) {
 	/* use data from buffer */
 	cur = *bufp;
-	if (left < size) {
-	    _zip_error_set(error, ZIP_ER_NOZIP, 0);
-	    return -1;
-	}
     }
     else {
 	/* read entry from disk */
@@ -212,11 +241,10 @@ _zip_dirent_read(struct zip_dirent *zde,
 	    _zip_error_set(error, ZIP_ER_READ, errno);
 	    return -1;
 	}
-	left = size;
 	cur = buf;
     }
 
-    if (memcmp(cur, (localp ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) {
+    if (memcmp(cur, (local ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) {
 	_zip_error_set(error, ZIP_ER_NOZIP, 0);
 	return -1;
     }
@@ -225,7 +253,7 @@ _zip_dirent_read(struct zip_dirent *zde,
     
     /* convert buffercontents to zip_dirent */
     
-    if (!localp)
+    if (!local)
 	zde->version_madeby = _zip_read2(&cur);
     else
 	zde->version_madeby = 0;
@@ -245,7 +273,7 @@ _zip_dirent_read(struct zip_dirent *zde,
     zde->filename_len = _zip_read2(&cur);
     zde->extrafield_len = _zip_read2(&cur);
     
-    if (localp) {
+    if (local) {
 	zde->comment_len = 0;
 	zde->disk_number = 0;
 	zde->int_attrib = 0;
@@ -263,13 +291,14 @@ _zip_dirent_read(struct zip_dirent *zde,
     zde->extrafield = NULL;
     zde->comment = NULL;
 
-    if (bufp) {
-	if (left < CDENTRYSIZE + (zde->filename_len+zde->extrafield_len
-				  +zde->comment_len)) {
-	    _zip_error_set(error, ZIP_ER_NOZIP, 0);
-	    return -1;
-	}
+    size += zde->filename_len+zde->extrafield_len+zde->comment_len;
+
+    if (leftp && (*leftp < size)) {
+	_zip_error_set(error, ZIP_ER_NOZIP, 0);
+	return -1;
+    }
 
+    if (bufp) {
 	if (zde->filename_len) {
 	    zde->filename = _zip_readstr(&cur, zde->filename_len, 1, error);
 	    if (!zde->filename)
@@ -312,6 +341,8 @@ _zip_dirent_read(struct zip_dirent *zde,
 
     if (bufp)
       *bufp = cur;
+    if (leftp)
+	*leftp -= size;
 
     return 0;
 }
--- a/lib/zip_file_get_offset.c
+++ b/lib/zip_file_get_offset.c
@@ -63,7 +63,7 @@ _zip_file_get_offset(struct zip *za, int
 	return 0;
     }
 
-    if (_zip_dirent_read(&de, za->zp, NULL, 0, 1, &za->error) != 0)
+    if (_zip_dirent_read(&de, za->zp, NULL, NULL, 1, &za->error) != 0)
 	return 0;
 
     offset += LENTRYSIZE + de.filename_len + de.extrafield_len;
--- a/lib/zip_open.c
+++ b/lib/zip_open.c
@@ -154,6 +154,7 @@ _zip_readcdir(FILE *fp, unsigned char *b
     struct zip_cdir *cd;
     unsigned char *cdp, **bufp;
     int i, comlen, nentry;
+    unsigned int left;
 
     comlen = buf + buflen - eocd - EOCDLEN;
     if (comlen < 0) {
@@ -207,7 +208,6 @@ _zip_readcdir(FILE *fp, unsigned char *b
 	}
     }
 
-    cdp = eocd;
     if (cd->size < (unsigned int)(eocd-buf)) {
 	/* if buffer already read in, use it */
 	cdp = eocd - cd->size;
@@ -231,14 +231,23 @@ _zip_readcdir(FILE *fp, unsigned char *b
 	}
     }
 
-    for (i=0; i<cd->nentry; i++) {
-	if ((_zip_dirent_read(cd->entry+i, fp, bufp, eocd-cdp, 0,
-			      error)) < 0) {
+    left = cd->size;
+    i=0;
+    do {
+	if (i == cd->nentry && left > 0) {
+	    /* Infozip extension for more than 64k entries:
+	       nentries wraps around, size indicates correct EOCD */
+	    _zip_cdir_grow(cd, cd->nentry+0x10000, error);
+	}
+
+	if ((_zip_dirent_read(cd->entry+i, fp, bufp, &left, 0, error)) < 0) {
 	    cd->nentry = i;
 	    _zip_cdir_free(cd);
 	    return NULL;
 	}
-    }
+	i++;
+	
+    } while (i<cd->nentry);
     
     return cd;
 }
@@ -287,7 +296,7 @@ _zip_checkcons(FILE *fp, struct zip_cdir
 	    return -1;
 	}
 	
-	if (_zip_dirent_read(&temp, fp, NULL, 0, 1, error) == -1)
+	if (_zip_dirent_read(&temp, fp, NULL, NULL, 1, error) == -1)
 	    return -1;
 	
 	if (_zip_headercomp(cd->entry+i, 0, &temp, 1) != 0) {
--- a/lib/zipint.h
+++ b/lib/zipint.h
@@ -217,13 +217,14 @@ extern const int _zip_err_type[];
 
 int _zip_cdir_compute_crc(struct zip *, uLong *);
 void _zip_cdir_free(struct zip_cdir *);
+int _zip_cdir_grow(struct zip_cdir *, int, struct zip_error *);
 struct zip_cdir *_zip_cdir_new(int, struct zip_error *);
 int _zip_cdir_write(struct zip_cdir *, FILE *, struct zip_error *);
 
 void _zip_dirent_finalize(struct zip_dirent *);
 void _zip_dirent_init(struct zip_dirent *);
-int _zip_dirent_read(struct zip_dirent *, FILE *,
-		     unsigned char **, unsigned int, int, struct zip_error *);
+int _zip_dirent_read(struct zip_dirent *, FILE *, unsigned char **,
+		     unsigned int *, int, struct zip_error *);
 void _zip_dirent_torrent_normalize(struct zip_dirent *);
 int _zip_dirent_write(struct zip_dirent *, FILE *, int, struct zip_error *);
 
